import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import {
    Paper,
    Typography,
    Box,
    CircularProgress,
    Alert,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Chip,
    Grid,
    Card,
    CardContent
} from '@mui/material';
import {
    TrendingUp as TrendingUpIcon,
    Speed as SpeedIcon,
    Visibility as ViewsIcon,
    ShowChart as ChartIcon
} from '@mui/icons-material';
import { useAppStore } from '../store/appStore.js';

// Stable Chart Component with Memoization
const StableChart = React.memo(({ data, timeRange }) => {
    // Dynamic import to prevent SSR issues and reduce bundle size
    const [ChartComponents, setChartComponents] = useState(null);
    const [chartError, setChartError] = useState(null);

    useEffect(() => {
        let mounted = true;
        
        const loadChartComponents = async () => {
            try {
                const recharts = await import('recharts');
                if (mounted) {
                    setChartComponents({
                        ResponsiveContainer: recharts.ResponsiveContainer,
                        AreaChart: recharts.AreaChart,
                        Area: recharts.Area,
                        XAxis: recharts.XAxis,
                        YAxis: recharts.YAxis,
                        CartesianGrid: recharts.CartesianGrid,
                        Tooltip: recharts.Tooltip,
                        Legend: recharts.Legend
                    });
                }
            } catch (error) {
                console.error('Failed to load chart components:', error);
                if (mounted) {
                    setChartError('Failed to load chart library');
                }
            }
        };

        loadChartComponents();
        
        return () => {
            mounted = false;
        };
    }, []);

    // Custom Tooltip component
    const CustomTooltip = useCallback(({ active, payload, label }) => {
        if (active && payload && payload.length) {
            return (
                <Paper variant="legend">
                    <Typography variant="sectionTitle">
                        {label}
                    </Typography>
                    {payload.map((entry, index) => (
                        <Typography 
                            key={index} 
                            variant="body2" 
                            sx={{ color: entry.color }}
                        >
                            {entry.name}: {Number(entry.value).toLocaleString()}
                        </Typography>
                    ))}
                </Paper>
            );
        }
        return null;
    }, []);

    // Stable chart data with proper key generation
    const stableData = useMemo(() => {
        if (!data || !Array.isArray(data)) return [];
        
        return data.map((item, index) => ({
            ...item,
            key: `${item.timestamp || index}-${item.time || index}`, // Stable key
            views: Number(item.views) || 0,
            likes: Number(item.likes) || 0,
            shares: Number(item.shares) || 0,
            comments: Number(item.comments) || 0
        }));
    }, [data]);

    if (chartError) {
        return (
            <Alert variant="spaced" severity="error">
                Chart library failed to load. Please refresh the page.
            </Alert>
        );
    }

    if (!ChartComponents) {
        return (
            <Box variant="emptyState">
                <CircularProgress />
                <Typography variant="withIcon">
                    Loading chart...
                </Typography>
            </Box>
        );
    }

    if (!stableData || stableData.length === 0) {
        return (
            <Box variant="emptyState" sx={{ color: 'text.secondary' }}>
                <ChartIcon variant="large" />
                <Typography variant="h6" gutterBottom>
                    No data available
                </Typography>
                <Typography variant="body2">
                    No post activity data for the selected time range
                </Typography>
            </Box>
        );
    }

    const { ResponsiveContainer, AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend } = ChartComponents;

    return (
        <Box variant="chartContainer">
            <ResponsiveContainer width="100%" height="100%">
                <AreaChart 
                    data={stableData} 
                    margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
                    key={`chart-${timeRange}-${stableData.length}`} // Force re-render on data change
                >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                        dataKey="time" 
                        tick={{ fontSize: 12 }}
                        interval="preserveStartEnd"
                        type="category"
                        allowDuplicatedCategory={false}
                    />
                    <YAxis 
                        tick={{ fontSize: 12 }}
                        tickFormatter={(value) => Number(value).toLocaleString()}
                        type="number"
                        allowDataOverflow={false}
                    />
                    <Tooltip content={<CustomTooltip />} />
                    <Legend />
                    <Area
                        type="monotone"
                        dataKey="views"
                        stackId="1"
                        stroke="#8884d8"
                        fill="#8884d8"
                        fillOpacity={0.6}
                        name="Views"
                        animationDuration={300}
                    />
                    <Area
                        type="monotone"
                        dataKey="likes"
                        stackId="1"
                        stroke="#82ca9d"
                        fill="#82ca9d"
                        fillOpacity={0.6}
                        name="Likes"
                        animationDuration={300}
                    />
                    <Area
                        type="monotone"
                        dataKey="shares"
                        stackId="1"
                        stroke="#ffc658"
                        fill="#ffc658"
                        fillOpacity={0.6}
                        name="Shares"
                        animationDuration={300}
                    />
                </AreaChart>
            </ResponsiveContainer>
        </Box>
    );
}, (prevProps, nextProps) => {
    // Custom comparison to prevent unnecessary re-renders
    return (
        prevProps.timeRange === nextProps.timeRange &&
        JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data)
    );
});

StableChart.displayName = 'StableChart';

// Error Boundary Component
class ChartErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
    }

    static getDerivedStateFromError(error) {
        return { hasError: true, error };
    }

    componentDidCatch(error, errorInfo) {
        console.error('Chart Error:', error, errorInfo);
    }

    render() {
        if (this.state.hasError) {
            return (
                <Alert severity="error" variant="spaced">
                    Chart ma'lumotlarini ko'rsatishda xatolik yuz berdi. Sahifani yangilang.
                </Alert>
            );
        }

        return this.props.children;
    }
}

const PostViewDynamicsChart = () => {
    const [timeRange, setTimeRange] = useState('24h');
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [data, setData] = useState([]);
    const [autoRefresh] = useState(true);
    const [refreshInterval, setRefreshInterval] = useState('30s');
    
    // Get store methods
    const { fetchPostDynamics } = useAppStore();
    
    // Use refs to track state and prevent unnecessary re-renders
    const isMountedRef = useRef(true);
    const dataRef = useRef([]);
    const timeRangeRef = useRef(timeRange);
    const isLoadingRef = useRef(false);

    // Stable load data function with debouncing
    const loadData = useCallback(async () => {
        if (isLoadingRef.current) {
            console.log('PostViewDynamicsChart: Skipping load - already loading');
            return;
        }

        isLoadingRef.current = true;
        setLoading(true);
        setError(null);

        try {
            const currentTimeRange = timeRangeRef.current;
            console.log('PostViewDynamicsChart: Loading data for timeRange:', currentTimeRange);
            
            const result = await fetchPostDynamics(currentTimeRange);
            
            if (isMountedRef.current) {
                dataRef.current = result || [];
                setRawData(result || []);
                dataVersionRef.current += 1;
            }
        } catch (err) {
            console.error('PostViewDynamicsChart: Error loading data:', err);
            if (isMountedRef.current) {
                setError(err.message || 'Failed to load analytics data');
            }
        } finally {
            if (isMountedRef.current) {
                setLoading(false);
            }
            isLoadingRef.current = false;
        }
    }, []); // Remove fetchPostDynamics dependency to prevent infinite loops
    
    // Handle time range changes with debouncing
    const handleTimeRangeChange = useCallback((newTimeRange) => {
        timeRangeRef.current = newTimeRange;
        setTimeRange(newTimeRange);
        
        // Debounce time range changes to prevent rapid API calls
        setTimeout(() => {
            if (isMountedRef.current && timeRangeRef.current === newTimeRange) {
                loadData();
            }
        }, 300);
    }, []); // No dependencies to prevent infinite loops

    // Initial load (only once)
    useEffect(() => {
        let mounted = true;
        
        const initialLoad = async () => {
            // Small delay to avoid race conditions
            await new Promise(resolve => setTimeout(resolve, 100));
            if (mounted && isMountedRef.current) {
                loadData();
            }
        };
        
        initialLoad();
        
        return () => {
            mounted = false;
        };
    }, []); // Empty dependency array for initial load only
    
    // Listen for data source changes (with debouncing)
    useEffect(() => {
        let timeoutId;
        
        const handleDataSourceChange = () => {
            console.log('PostViewDynamicsChart: Data source changed, reloading...');
            
            // Clear any pending reload
            if (timeoutId) clearTimeout(timeoutId);
            
            // Debounce the reload to prevent rapid successive calls
            timeoutId = setTimeout(() => {
                if (isMountedRef.current) {
                    loadData();
                }
            }, 500); // 500ms debounce for data source changes
        };
        
        window.addEventListener('dataSourceChanged', handleDataSourceChange);
        
        return () => {
            window.removeEventListener('dataSourceChanged', handleDataSourceChange);
            if (timeoutId) clearTimeout(timeoutId);
        };
    }, []); // No dependencies to prevent infinite loops

    // Auto-refresh functionality with cleanup (disabled by default to prevent loops)
    useEffect(() => {
        // Disable auto-refresh by default to prevent infinite API calls
        if (!autoRefresh || refreshInterval === 'disabled') return;

        const intervalMs = refreshInterval === '30s' ? 30000 : 
                          refreshInterval === '1m' ? 60000 : 
                          refreshInterval === '5m' ? 300000 : 30000;

        console.log('PostViewDynamicsChart: Setting up auto-refresh every', intervalMs, 'ms');
        
        const interval = setInterval(() => {
            if (isMountedRef.current && !isLoadingRef.current) {
                console.log('PostViewDynamicsChart: Auto-refresh triggered');
                loadData();
            }
        }, intervalMs);
        
        return () => {
            console.log('PostViewDynamicsChart: Clearing auto-refresh interval');
            clearInterval(interval);
        };
    }, [autoRefresh, refreshInterval]); // Removed loadData dependency

    // Cleanup when component unmounts
    useEffect(() => {
        return () => {
            isMountedRef.current = false;
        };
    }, []);

    // Chart data transformation with enhanced validation and memoization
    const chartData = useMemo(() => {
        if (!data || !Array.isArray(data) || data.length === 0) {
            return [];
        }
        
        try {
            const transformedData = data.map((point, index) => {
                if (!point || typeof point !== 'object') {
                    return null;
                }
                
                return {
                    time: point.timestamp ? 
                        new Date(point.timestamp).toLocaleTimeString('en-US', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        }) : 
                        point.time || `Point ${index + 1}`,
                    views: Math.max(0, Number(point.views) || 0),
                    likes: Math.max(0, Number(point.likes || point.reactions) || 0),
                    shares: Math.max(0, Number(point.shares || point.forwards) || 0),
                    comments: Math.max(0, Number(point.comments) || 0),
                    timestamp: point.timestamp || new Date().toISOString()
                };
            }).filter(Boolean);
            
            return transformedData;
        } catch (error) {
            console.error('Error transforming chart data:', error);
            return [];
        }
    }, [data]);

    // Summary statistics with memoization
    const summaryStats = useMemo(() => {
        if (!chartData || chartData.length === 0) return null;

        try {
            const latest = chartData[chartData.length - 1] || {};
            const previous = chartData[chartData.length - 2] || {};
            
            const total = chartData.reduce((sum, item) => sum + (item.views || 0), 0);
            const avgViews = Math.round(total / chartData.length) || 0;
            const currentViews = latest.views || 0;
            const previousViews = previous.views || 0;
            const growth = previousViews > 0 ? ((currentViews - previousViews) / previousViews * 100) : 0;

            return {
                totalViews: total,
                currentViews,
                averageViews: avgViews,
                growthRate: Number(growth.toFixed(1)),
                peakViews: Math.max(...chartData.map(d => d.views || 0)),
                dataPoints: chartData.length
            };
        } catch (error) {
            console.error('Error calculating summary stats:', error);
            return null;
        }
    }, [chartData]);

    if (error) {
        return (
            <Paper variant="card">
                <Alert severity="error" variant="spaced">
                    Ma'lumotlarni yuklashda xatolik: {error}
                </Alert>
            </Paper>
        );
    }

    return (
        <Paper variant="card">
            {/* Header */}
            <Box variant="headerControls">
                <Box variant="flexRow">
                    <ChartIcon color="primary" />
                    <Typography variant="h6">
                        Post View Dynamics
                    </Typography>
                </Box>
                
                <Box variant="actionControls">
                    {/* Time Range Selector */}
                    <FormControl size="small" variant="compact">
                        <InputLabel>Time Range</InputLabel>
                        <Select
                            value={timeRange}
                            label="Time Range"
                            onChange={(e) => handleTimeRangeChange(e.target.value)}
                        >
                            <MenuItem value="1h">1 Hour</MenuItem>
                            <MenuItem value="6h">6 Hours</MenuItem>
                            <MenuItem value="24h">24 Hours</MenuItem>
                            <MenuItem value="7d">7 Days</MenuItem>
                            <MenuItem value="30d">30 Days</MenuItem>
                        </Select>
                    </FormControl>

                    {/* Refresh Interval */}
                    <FormControl size="small" variant="compact">
                        <InputLabel>Refresh</InputLabel>
                        <Select
                            value={refreshInterval}
                            label="Refresh"
                            onChange={(e) => setRefreshInterval(e.target.value)}
                        >
                            <MenuItem value="30s">30 seconds</MenuItem>
                            <MenuItem value="1m">1 minute</MenuItem>
                            <MenuItem value="5m">5 minutes</MenuItem>
                            <MenuItem value="disabled">Disabled</MenuItem>
                        </Select>
                    </FormControl>
                </Box>
            </Box>

            {/* Summary Stats Cards */}
            {summaryStats && (
                <Grid container spacing={2} variant="metricsGrid">
                    <Grid item xs={6} sm={3}>
                        <Card variant="outlined">
                            <CardContent variant="metric">
                                <Box variant="iconText">
                                    <ViewsIcon color="primary" fontSize="small" />
                                    <Typography variant="caption" color="text.secondary">
                                        Total Views
                                    </Typography>
                                </Box>
                                <Typography variant="h6">
                                    {summaryStats.totalViews.toLocaleString()}
                                </Typography>
                            </CardContent>
                        </Card>
                    </Grid>
                    
                    <Grid item xs={6} sm={3}>
                        <Card variant="outlined">
                            <CardContent variant="metric">
                                <Box variant="iconText">
                                    <SpeedIcon color="secondary" fontSize="small" />
                                    <Typography variant="caption" color="text.secondary">
                                        Average
                                    </Typography>
                                </Box>
                                <Typography variant="h6">
                                    {summaryStats.averageViews.toLocaleString()}
                                </Typography>
                            </CardContent>
                        </Card>
                    </Grid>

                    <Grid item xs={6} sm={3}>
                        <Card variant="outlined">
                            <CardContent variant="metric">
                                <Box variant="iconText">
                                    <TrendingUpIcon color="success" fontSize="small" />
                                    <Typography variant="caption" color="text.secondary">
                                        Growth %
                                    </Typography>
                                </Box>
                                <Typography variant="h6" sx={{ 
                                    color: summaryStats.growthRate >= 0 ? 'success.main' : 'error.main' 
                                }}>
                                    {summaryStats.growthRate > 0 ? '+' : ''}{summaryStats.growthRate}%
                                </Typography>
                            </CardContent>
                        </Card>
                    </Grid>

                    <Grid item xs={6} sm={3}>
                        <Card variant="outlined">
                            <CardContent variant="metric">
                                <Box variant="iconText">
                                    <ChartIcon color="warning" fontSize="small" />
                                    <Typography variant="caption" color="text.secondary">
                                        Peak Views
                                    </Typography>
                                </Box>
                                <Typography variant="h6">
                                    {summaryStats.peakViews.toLocaleString()}
                                </Typography>
                            </CardContent>
                        </Card>
                    </Grid>
                </Grid>
            )}

            {/* Loading State */}
            {loading && (
                <Box variant="emptyState">
                    <CircularProgress />
                    <Typography variant="withIcon">
                        Loading analytics data...
                    </Typography>
                </Box>
            )}

            {/* Chart */}
            {!loading && chartData.length > 0 && (
                <StableChart data={chartData} timeRange={timeRange} />
            )}

            {/* Empty State */}
            {!loading && chartData.length === 0 && (
                <Box variant="emptyState" sx={{ height: 300, color: 'text.secondary' }}>
                    <ChartIcon variant="large" />
                    <Typography variant="h6" gutterBottom>
                        No data available
                    </Typography>
                    <Typography variant="body2">
                        No post activity data for the selected time range
                    </Typography>
                </Box>
            )}

            {/* Status indicator */}
            <Box variant="statusFooter">
                <Typography variant="caption" color="text.secondary">
                    So'ngi yangilash: {new Date().toLocaleTimeString()}
                </Typography>
                <Box variant="chipGroup">
                    {autoRefresh && refreshInterval !== 'disabled' && (
                        <Chip 
                            size="small" 
                            label="🔄 Avtomatik yangilash" 
                            color="primary" 
                            variant="outlined"
                        />
                    )}
                    {summaryStats && summaryStats.growthRate > 10 && (
                        <Chip 
                            size="small" 
                            label={<><span aria-hidden="true">📈</span> Yuqori o'sish</>}
                            color="success" 
                        />
                    )}
                </Box>
            </Box>
        </Paper>
    );
};

export default function PostViewDynamicsChartWrapper() {
    return (
        <ChartErrorBoundary>
            <PostViewDynamicsChart />
        </ChartErrorBoundary>
    );
}
