"""
ğŸš€ UNIFIED DEPENDENCY CONTAINER
Combined punq and dependency_injector approach with performance optimization
"""
from __future__ import annotations

import asyncio
import logging
from typing import TypeVar, Type, cast, Optional, Callable, Any, Dict
import inspect

import punq
from bot.utils.punctuated import Singleton

from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties

# Logging setup
logger = logging.getLogger(__name__)

# Aiogram identity (v3)
try:
    from aiogram.client.bot import Bot as _AioBot
except Exception:  # pragma: no cover
    from aiogram import Bot as _AioBot

from aiogram import Bot as _ClientBot
from aiogram import Dispatcher as _AioDispatcher

# DB turlari
from sqlalchemy.ext.asyncio import async_sessionmaker
from asyncpg.pool import Pool as AsyncPGPool

# Project config & DB
from bot.config import Settings
from bot.database.db import create_pool

# Repositories
from bot.database.repositories.analytics_repository import AnalyticsRepository
from bot.database.repositories.channel_repository import ChannelRepository
from bot.database.repositories.plan_repository import PlanRepository
from bot.database.repositories.scheduler_repository import SchedulerRepository
from bot.database.repositories.user_repository import UserRepository


# ---------- helper: lazy singleton factory ----------
def as_singleton(factory: Callable[[], object]) -> Callable[[], object]:
    _cache: dict[str, object] = {}

    def _wrapper() -> object:
        if "v" not in _cache:
            _cache["v"] = factory()
        return _cache["v"]

    return _wrapper


class Container(punq.Container):
    # Settings (punctuated)
    config = Singleton(Settings)

    # DB pool (punctuated) â€“ create_pool async boâ€˜lishi mumkin
    db_session = Singleton(create_pool)


# Global container
container = Container()


# ---------- Aiogram Bot/Dispatcher ----------
def _build_bot() -> _AioBot:
    cfg: Settings = cast(Settings, container.config)
    token: Optional[str]
    try:
        token = cfg.BOT_TOKEN.get_secret_value()
    except Exception:
        import os

        token = os.getenv("BOT_TOKEN")
    if not token or token == "replace_me":
        raise RuntimeError("BOT_TOKEN is missing or placeholder")
    return _AioBot(token=token, default=DefaultBotProperties(parse_mode=ParseMode.HTML))


def _build_dispatcher() -> _AioDispatcher:
    from aiogram.fsm.storage.memory import MemoryStorage

    return _AioDispatcher(storage=MemoryStorage())


_bot_singleton = as_singleton(_build_bot)
_dp_singleton = as_singleton(_build_dispatcher)

container.register(_AioBot, factory=_bot_singleton)
container.register(_ClientBot, factory=_bot_singleton)
container.register(_AioDispatcher, factory=_dp_singleton)


# ---------- Helperlar ----------
def _val(x: Any) -> Any:
    """punctuated.Singleton bo'lsa, instansiyani qaytaradi (cache bilan)."""
    return x() if callable(x) else x


def _pool_or_none() -> Optional[Any]:
    """
    Get database pool with improved error handling.
    Returns DB (asyncpg Pool or async_sessionmaker) or None if not available.
    """
    try:
        pool_value = _val(container.db_session)
        
        # If it's a coroutine and warmup hasn't happened, return None
        if hasattr(pool_value, "__await__"):
            logger.warning("Database pool not initialized (warmup required)")
            return None
            
        return pool_value
    except Exception as e:
        from bot.utils.error_handler import ErrorHandler, ErrorContext
        context = ErrorContext().add("operation", "get_database_pool")
        ErrorHandler.handle_database_error(e, context)
        return None


def _make_repo(RepoCls: type) -> object:
    """
    Moslashuvchan repo yaratuvchi: pool/redis positional yoki turli keywordlar.
    """
    pool = _pool_or_none()
    # Agar warmup bo'lmagan bo'lsa va coroutine kelsa â€“ None uzatamiz
    if hasattr(pool, "__await__"):
        pool = None

    # 1) Pozitsion (Repository(pool))
    try:
        return RepoCls(pool)
    except TypeError:
        pass

    # 2) Muqobil keyword nomlar
    for kw in (
        "session_pool",
        "session",
        "pool",
        "db",
        "database",
        "redis",
        "redis_client",
    ):
        try:
            return RepoCls(**{kw: pool})
        except TypeError:
            continue

    # 3) Umuman argsiz
    return RepoCls()


def _make_service(ServiceCls: type) -> object:
    """
    Servislarni __init__ signaturasiga moslab yig'ish.
    Bot va repos nomlarini introspeksiya qilamiz.
    """
    sig = inspect.signature(ServiceCls.__init__)
    names = set(sig.parameters.keys())

    kwargs: dict[str, Any] = {}

    # Bot
    if "bot" in names:
        kwargs["bot"] = container.resolve(_AioBot)

    # Repos
    if {"channel_repository", "channel_repo", "repository"} & names:
        repo = container.resolve(ChannelRepository)
        for cand in ("channel_repository", "channel_repo", "repository"):
            if cand in names:
                kwargs[cand] = repo
                break

    if {"scheduler_repository", "scheduler_repo"} & names:
        repo = container.resolve(SchedulerRepository)
        for cand in ("scheduler_repository", "scheduler_repo"):
            if cand in names:
                kwargs[cand] = repo
                break

    if {"user_repository", "user_repo"} & names:
        repo = container.resolve(UserRepository)
        for cand in ("user_repository", "user_repo"):
            if cand in names:
                kwargs[cand] = repo
                break

    if "analytics_repository" in names:
        kwargs["analytics_repository"] = container.resolve(AnalyticsRepository)

    # Qo'shimcha ehtimoliy paramlar (agar bo'lsa)
    if "plan_repository" in names:
        kwargs["plan_repository"] = container.resolve(PlanRepository)

    # Chaqaramiz
    try:
        return ServiceCls(**kwargs)
    except TypeError:
        # Agar baribir nomi boshqa bo'lsa, argumentsiz urinamiz
        return ServiceCls()


# ---------- DB aliaslar (DependencyMiddleware uchun) ----------
container.register(AsyncPGPool, factory=lambda: cast(AsyncPGPool, _pool_or_none()))
container.register(
    async_sessionmaker, factory=lambda: cast(async_sessionmaker, _pool_or_none())
)

# ---------- Repository factory'lari (punq) ----------
container.register(
    UserRepository, factory=as_singleton(lambda: _make_repo(UserRepository))
)
container.register(
    PlanRepository, factory=as_singleton(lambda: _make_repo(PlanRepository))
)
container.register(
    ChannelRepository, factory=as_singleton(lambda: _make_repo(ChannelRepository))
)
container.register(
    SchedulerRepository, factory=as_singleton(lambda: _make_repo(SchedulerRepository))
)
container.register(
    AnalyticsRepository, factory=as_singleton(lambda: _make_repo(AnalyticsRepository))
)

# ---------- Service factory'lari (punq) ----------
try:
    from bot.services.guard_service import GuardService
    from bot.services.subscription_service import SubscriptionService
    from bot.services.scheduler_service import SchedulerService
    from bot.services.analytics_service import AnalyticsService

    container.register(
        GuardService, factory=as_singleton(lambda: _make_service(GuardService))
    )
    container.register(
        SubscriptionService,
        factory=as_singleton(lambda: _make_service(SubscriptionService)),
    )
    container.register(
        SchedulerService, factory=as_singleton(lambda: _make_service(SchedulerService))
    )
    container.register(
        AnalyticsService, factory=as_singleton(lambda: _make_service(AnalyticsService))
    )
except Exception:
    # optional import failures allowed
    pass


# -------- Typed helper (Pylance uchun) --------
_T = TypeVar("_T")


def _resolve(key: Type[_T]) -> _T:
    """Legacy resolve function for backward compatibility"""
    return cast(_T, container.resolve(key))
    SchedulerService, factory=as_singleton(lambda: _make_service(SchedulerService))
)
legacy_container.register(
    AnalyticsService, factory=as_singleton(lambda: _make_service(AnalyticsService))
)


# ========================================================================
# OPTIMIZED DEPENDENCY-INJECTOR CONTAINER (Primary container)
# ========================================================================

class OptimizedContainer(containers.DeclarativeContainer):
    """ğŸ”¥ High-performance dependency injection container with all optimizations"""
    
    # Configuration
    config = providers.Configuration()
    
    # Performance components (initialized early)
    performance_manager = providers.Singleton(
        lambda: performance_manager
    )
    
    # Database components
    database_manager = providers.Singleton(
        lambda: db_manager
    )
    
    database_pool = providers.Resource(
        providers.Coroutine(
            db_manager.create_pool
        )
    )
    
    # Bot components with enhanced session
    bot_session = providers.Singleton(
        AiohttpSession,
        connector_limit=100,
        connector_limit_per_host=30,
        connector_ttl_dns_cache=300,
        connector_use_dns_cache=True,
        timeout_read=30,
        timeout_connect=10
    )
    
    bot = providers.Singleton(
        Bot,
        token=settings.BOT_TOKEN.get_secret_value(),
        session=bot_session
    )
    
    dispatcher = providers.Singleton(Dispatcher)
    
    # Repository layer with connection pooling
    user_repository = providers.Singleton(
        UserRepository,
        db_pool=database_pool
    )
    
    channel_repository = providers.Singleton(
        ChannelRepository,
        db_pool=database_pool
    )
    
    analytics_repository = providers.Singleton(
        AnalyticsRepository,
        db_pool=database_pool
    )
    
    scheduler_repository = providers.Singleton(
        SchedulerRepository,
        db_pool=database_pool
    )
    
    plan_repository = providers.Singleton(
        PlanRepository,
        db_pool=database_pool
    )
    
    # Unified analytics service
    analytics_service = providers.Singleton(
        AnalyticsService,
        bot=bot,
        analytics_repository=analytics_repository
    )
    
    # Core services
    guard_service = providers.Singleton(
        GuardService,
        user_repository=user_repository,
        channel_repository=channel_repository
    )
    
    subscription_service = providers.Singleton(
        SubscriptionService,
        user_repository=user_repository,
        plan_repository=plan_repository
    )
    
    scheduler_service = providers.Singleton(
        SchedulerService,
        scheduler_repository=scheduler_repository,
        bot=bot
    )
    
    # Monitoring services
    prometheus_service = providers.Singleton(
        lambda: prometheus_service
    )


# Add ML services if available
if ML_SERVICES_AVAILABLE:
    # ML/AI Service Layer (Phase 2.5)
    OptimizedContainer.prediction_service = providers.Singleton(
        PredictionService,
        cache_service=providers.Object("performance_manager.cache"),
        db_service=OptimizedContainer.database_manager
    )
    
    OptimizedContainer.content_optimizer = providers.Singleton(
        ContentOptimizer,
        cache_service=providers.Object("performance_manager.cache"),
        analytics_service=OptimizedContainer.analytics_service
    )
    
    OptimizedContainer.churn_predictor = providers.Singleton(
        ChurnPredictor,
        db_service=OptimizedContainer.database_manager,
        analytics_service=OptimizedContainer.analytics_service,
        cache_service=providers.Object("performance_manager.cache")
    )
    
    OptimizedContainer.engagement_analyzer = providers.Singleton(
        EngagementAnalyzer,
        prediction_service=OptimizedContainer.prediction_service,
        content_optimizer=OptimizedContainer.content_optimizer,
        churn_predictor=OptimizedContainer.churn_predictor,
        db_service=OptimizedContainer.database_manager,
        cache_service=providers.Object("performance_manager.cache")
    )


class UnifiedContainer:
    """ğŸš€ Unified container with performance monitoring and health checks"""
    
    def __init__(self):
        self.container = Container()
        self.legacy_container = legacy_container
        self._initialized = False
        self._health_status: Dict[str, Any] = {}
        self._performance_metrics: Dict[str, float] = {}
        self._use_optimized = True  # Default to optimized container
    
    async def initialize(self) -> None:
        """ğŸš€ Initialize all services with performance monitoring"""
        if self._initialized:
            logger.info("ğŸ“¦ Container already initialized")
            return
        
        start_time = asyncio.get_event_loop().time()
        
        try:
            logger.info("ğŸ”§ Initializing unified container...")
            
            # Try optimized initialization first
            try:
                await self._initialize_optimized()
                self._use_optimized = True
                logger.info("ğŸš€ Using optimized container")
            except Exception as e:
                logger.warning(f"âš ï¸ Optimized container failed, falling back to legacy: {e}")
                await self._initialize_legacy()
                self._use_optimized = False
                logger.info("ğŸ“¦ Using legacy container")
            
            self._initialized = True
            
            init_time = asyncio.get_event_loop().time() - start_time
            logger.info(f"âœ… Unified container initialized in {init_time:.3f}s")
            
        except Exception as e:
            logger.error(f"âŒ Container initialization failed: {e}")
            raise
    
    async def _initialize_optimized(self):
        """Initialize optimized container with all features"""
        # Initialize performance components first
        await self._initialize_performance_layer()
        
        # Initialize database layer
        await self._initialize_database_layer()
        
        # Initialize service layer
        await self._initialize_service_layer()
        
        # Initialize monitoring
        await self._initialize_monitoring()
        
        # Run health checks
        await self._initial_health_check()
    
    async def _initialize_legacy(self):
        """Initialize legacy container (fallback)"""
        logger.info("ğŸ“¦ Initializing legacy container")
        # Legacy container is already initialized
        pass
    
    async def _initialize_performance_layer(self):
        """Initialize performance optimization layer"""
        try:
            await performance_manager.initialize()
            logger.info("ğŸš€ Performance layer initialized")
        except Exception as e:
            logger.warning(f"âš ï¸ Performance layer initialization failed: {e}")
    
    async def _initialize_database_layer(self):
        """Initialize database connections with optimization"""
        try:
            # Initialize database pool
            await self.container.database_pool.provided()
            
            # Verify connection health
            if not await db_manager.health_check():
                raise Exception("Database health check failed")
            
            logger.info("ğŸ—„ï¸ Database layer initialized")
            
        except Exception as e:
            logger.error(f"âŒ Database initialization failed: {e}")
            raise
    
    async def _initialize_service_layer(self):
        """Initialize service layer components"""
        try:
            # Pre-warm service instances
            services = [
                'user_repository',
                'channel_repository', 
                'analytics_repository',
                'scheduler_repository',
                'plan_repository'
            ]
            
            for service_name in services:
                service = getattr(self.container, service_name)()  # noqa: F841
                logger.debug(f"ğŸ“ Initialized {service_name}")
            
            # Initialize ML services if available
            if ML_SERVICES_AVAILABLE:
                await self._initialize_ml_services()
            
            logger.info("ğŸ”§ Service layer initialized")
            
        except Exception as e:
            logger.error(f"âŒ Service layer initialization failed: {e}")
            raise
    
    async def _initialize_ml_services(self):
        """ğŸ¤– Initialize ML/AI services (Phase 2.5)"""
        try:
            logger.info("ğŸ¤– Initializing ML/AI services...")
            
            # Initialize prediction service
            prediction_service = self.container.prediction_service()
            await prediction_service.initialize_models()
            logger.debug("âœ… Prediction service initialized")
            
            # Initialize churn predictor
            churn_predictor = self.container.churn_predictor()
            await churn_predictor.initialize_model()
            logger.debug("âœ… Churn predictor initialized")
            
            # Initialize content optimizer and engagement analyzer (service warmup)
            self.container.content_optimizer()
            self.container.engagement_analyzer()
            logger.debug("âœ… Content optimizer and engagement analyzer initialized")
            
            logger.info("ğŸš€ ML/AI services initialized successfully")
            
        except Exception as e:
            logger.warning(f"âš ï¸ ML services initialization failed: {e}")
    
    async def _initialize_monitoring(self):
        """Initialize monitoring and metrics collection"""
        try:
            prometheus_service.start_http_server()
            logger.info("ğŸ“Š Monitoring initialized")
        except Exception as e:
            logger.warning(f"âš ï¸ Monitoring initialization failed: {e}")
    
    async def _initial_health_check(self):
        """Run comprehensive health check on all components"""
        health_checks = {
            'database': db_manager.health_check(),
            'cache': self._check_cache_health(),
            'bot': self._check_bot_health(),
        }
        
        if ML_SERVICES_AVAILABLE:
            health_checks['ml_services'] = self._check_ml_services_health()
        
        results = await asyncio.gather(
            *health_checks.values(),
            return_exceptions=True
        )
        
        self._health_status = dict(zip(health_checks.keys(), results))
        
        # Log health status
        for component, status in self._health_status.items():
            if isinstance(status, Exception):
                logger.warning(f"âš ï¸ {component} health check failed: {status}")
            elif status:
                logger.info(f"âœ… {component} healthy")
            else:
                logger.warning(f"âš ï¸ {component} unhealthy")
    
    async def _check_cache_health(self) -> bool:
        """Check cache connectivity"""
        try:
            return performance_manager.cache._is_connected
        except:
            return False
    
    async def _check_bot_health(self) -> bool:
        """Check bot connectivity"""
        try:
            bot = self.container.bot() if self._use_optimized else self.legacy_container.resolve(_AioBot)
            me = await bot.get_me()
            return bool(me)
        except:
            return False
    
    async def _check_ml_services_health(self) -> Dict[str, Any]:
        """ğŸ¤– Check ML services health"""
        if not ML_SERVICES_AVAILABLE or not self._use_optimized:
            return {'status': 'not_available'}
            
        try:
            ml_health = {}
            
            services_to_check = [
                'prediction_service',
                'content_optimizer', 
                'churn_predictor',
                'engagement_analyzer'
            ]
            
            for service_name in services_to_check:
                try:
                    service = getattr(self.container, service_name)()
                    ml_health[service_name] = await service.health_check()
                except Exception as e:
                    ml_health[service_name] = {'status': 'error', 'error': str(e)}
            
            return ml_health
            
        except Exception as e:
            return {'status': 'error', 'error': f'ML services health check failed: {e}'}
    
    def resolve(self, service_type: Type):
        """Resolve service from appropriate container"""
        if self._use_optimized:
            # Try optimized container first
            try:
                service_name = service_type.__name__.lower().replace('service', '_service')
                if service_name.endswith('_service_service'):
                    service_name = service_name.replace('_service_service', '_service')
                if not service_name.endswith('_service') and not service_name.endswith('_repository'):
                    if 'repository' in service_type.__name__.lower():
                        service_name += '_repository'
                    else:
                        service_name += '_service'
                
                return getattr(self.container, service_name)()
            except (AttributeError, Exception):
                # Fallback to legacy
                return self.legacy_container.resolve(service_type)
        else:
            return self.legacy_container.resolve(service_type)
    
    async def get_health_status(self) -> Dict[str, Any]:
        """Get current health status of all components"""
        if not self._initialized:
            return {"status": "not_initialized"}
        
        # Refresh health checks
        await self._initial_health_check()
        
        return {
            "initialized": self._initialized,
            "using_optimized": self._use_optimized,
            "components": self._health_status,
            "overall_healthy": all(
                isinstance(status, bool) and status 
                for status in self._health_status.values()
            )
        }
    
    async def get_performance_metrics(self) -> Dict[str, Any]:
        """Get performance metrics from all components"""
        if not self._initialized:
            return {"status": "not_initialized"}
        
        try:
            metrics = {"container_type": "optimized" if self._use_optimized else "legacy"}
            
            if self._use_optimized:
                # Database metrics
                if db_manager.pool:
                    metrics["database"] = await db_manager.get_performance_stats()
                
                # Performance manager metrics
                if performance_manager:
                    metrics["performance"] = await performance_manager.get_performance_stats()
            
            return metrics
            
        except Exception as e:
            logger.error(f"âŒ Failed to get performance metrics: {e}")
            return {"error": str(e)}
    
    async def shutdown(self):
        """ğŸ Graceful shutdown of all components"""
        if not self._initialized:
            return
        
        logger.info("ğŸ Shutting down unified container...")
        
        shutdown_tasks = []
        
        if self._use_optimized:
            # Close database connections
            if db_manager.pool:
                shutdown_tasks.append(db_manager.close_pool())
            
            # Close performance manager
            shutdown_tasks.append(performance_manager.close())
            
            # Close bot session
            try:
                bot = self.container.bot()
                if bot.session:
                    shutdown_tasks.append(bot.session.close())
            except:
                pass
            
            # Execute all shutdowns concurrently
            if shutdown_tasks:
                await asyncio.gather(*shutdown_tasks, return_exceptions=True)
        
        self._initialized = False
        logger.info("âœ… Container shutdown completed")
    
    def __getattr__(self, name):
        """Delegate attribute access to the appropriate container"""
        if not self._initialized:
            logger.warning(f"âš ï¸ Accessing {name} before container initialization")
        
        if self._use_optimized and hasattr(self.container, name):
            return getattr(self.container, name)
        elif hasattr(self.legacy_container, name):
            return getattr(self.legacy_container, name)
        else:
            # Try to resolve as a service
            try:
                service_name = name.replace('_service', '').replace('_repository', '')
                service_class = globals().get(service_name.title() + 'Service') or globals().get(service_name.title() + 'Repository')
                if service_class:
                    return lambda: self.resolve(service_class)
            except:
                pass
            
            raise AttributeError(f"'{self.__class__.__name__}' has no attribute '{name}'")


# Global unified container instance (Primary interface)
container = UnifiedContainer()


# ========================================================================
# LEGACY COMPATIBILITY EXPORTS
# ========================================================================

# Typed helper (Pylance uchun)
_T = TypeVar("_T")

def _resolve(key: Type[_T]) -> _T:
    """Legacy resolve function for backward compatibility"""
    return cast(_T, container.resolve(key))Var, Type, cast, Optional, Callable, Any
import inspect
import logging

import punq
from bot.utils.punctuated import Singleton

from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties

# Logging setup
logger = logging.getLogger(__name__)

# Aiogram identity (v3)
try:
    from aiogram.client.bot import Bot as _AioBot
except Exception:  # pragma: no cover
    from aiogram import Bot as _AioBot

from aiogram import Bot as _ClientBot
from aiogram import Dispatcher as _AioDispatcher

# DB turlari
from sqlalchemy.ext.asyncio import async_sessionmaker
from asyncpg.pool import Pool as AsyncPGPool

# Project config & DB
from bot.config import Settings
from bot.database.db import create_pool

# Repositories
from bot.database.repositories.analytics_repository import AnalyticsRepository
from bot.database.repositories.channel_repository import ChannelRepository
from bot.database.repositories.plan_repository import PlanRepository
from bot.database.repositories.scheduler_repository import SchedulerRepository
from bot.database.repositories.user_repository import UserRepository


# ---------- helper: lazy singleton factory ----------
def as_singleton(factory: Callable[[], object]) -> Callable[[], object]:
    _cache: dict[str, object] = {}

    def _wrapper() -> object:
        if "v" not in _cache:
            _cache["v"] = factory()
        return _cache["v"]

    return _wrapper


class Container(punq.Container):
    # Settings (punctuated)
    config = Singleton(Settings)

    # DB pool (punctuated) â€“ create_pool async boâ€˜lishi mumkin
    db_session = Singleton(create_pool)


# Global container
container = Container()


# ---------- Aiogram Bot/Dispatcher ----------
def _build_bot() -> _AioBot:
    cfg: Settings = cast(Settings, container.config)
    token: Optional[str]
    try:
        token = cfg.BOT_TOKEN.get_secret_value()
    except Exception:
        import os

        token = os.getenv("BOT_TOKEN")
    if not token or token == "replace_me":
        raise RuntimeError("BOT_TOKEN is missing or placeholder")
    return _AioBot(token=token, default=DefaultBotProperties(parse_mode=ParseMode.HTML))


def _build_dispatcher() -> _AioDispatcher:
    from aiogram.fsm.storage.memory import MemoryStorage

    return _AioDispatcher(storage=MemoryStorage())


_bot_singleton = as_singleton(_build_bot)
_dp_singleton = as_singleton(_build_dispatcher)

container.register(_AioBot, factory=_bot_singleton)
container.register(_ClientBot, factory=_bot_singleton)
container.register(_AioDispatcher, factory=_dp_singleton)


# ---------- Helperlar ----------
def _val(x: Any) -> Any:
    """punctuated.Singleton bo'lsa, instansiyani qaytaradi (cache bilan)."""
    return x() if callable(x) else x


def _pool_or_none() -> Optional[Any]:
    """
    Get database pool with improved error handling.
    Returns DB (asyncpg Pool or async_sessionmaker) or None if not available.
    """
    try:
        pool_value = _val(container.db_session)
        
        # If it's a coroutine and warmup hasn't happened, return None
        if hasattr(pool_value, "__await__"):
            logger.warning("Database pool not initialized (warmup required)")
            return None
            
        return pool_value
    except Exception as e:
        from bot.utils.error_handler import ErrorHandler, ErrorContext
        context = ErrorContext().add("operation", "get_database_pool")
        ErrorHandler.handle_database_error(e, context)
        return None


def _make_repo(RepoCls: type) -> object:
    """
    Moslashuvchan repo yaratuvchi: pool/redis positional yoki turli keywordlar.
    """
    pool = _pool_or_none()
    # Agar warmup bo'lmagan bo'lsa va coroutine kelsa â€“ None uzatamiz
    if hasattr(pool, "__await__"):
        pool = None

    # 1) Pozitsion (Repository(pool))
    try:
        return RepoCls(pool)
    except TypeError:
        pass

    # 2) Muqobil keyword nomlar
    for kw in (
        "session_pool",
        "session",
        "pool",
        "db",
        "database",
        "redis",
        "redis_client",
    ):
        try:
            return RepoCls(**{kw: pool})
        except TypeError:
            continue

    # 3) Umuman argsiz
    return RepoCls()


def _make_service(ServiceCls: type) -> object:
    """
    Servislarni __init__ signaturasiga moslab yig'ish.
    Bot va repos nomlarini introspeksiya qilamiz.
    """
    sig = inspect.signature(ServiceCls.__init__)
    names = set(sig.parameters.keys())

    kwargs: dict[str, Any] = {}

    # Bot
    if "bot" in names:
        kwargs["bot"] = container.resolve(_AioBot)

    # Repos
    if {"channel_repository", "channel_repo", "repository"} & names:
        repo = container.resolve(ChannelRepository)
        for cand in ("channel_repository", "channel_repo", "repository"):
            if cand in names:
                kwargs[cand] = repo
                break

    if {"scheduler_repository", "scheduler_repo"} & names:
        repo = container.resolve(SchedulerRepository)
        for cand in ("scheduler_repository", "scheduler_repo"):
            if cand in names:
                kwargs[cand] = repo
                break

    if {"user_repository", "user_repo"} & names:
        repo = container.resolve(UserRepository)
        for cand in ("user_repository", "user_repo"):
            if cand in names:
                kwargs[cand] = repo
                break

    if "analytics_repository" in names:
        kwargs["analytics_repository"] = container.resolve(AnalyticsRepository)

    # Qo'shimcha ehtimoliy paramlar (agar bo'lsa)
    if "plan_repository" in names:
        kwargs["plan_repository"] = container.resolve(PlanRepository)

    # Chaqaramiz
    try:
        return ServiceCls(**kwargs)
    except TypeError:
        # Agar baribir nomi boshqa bo'lsa, argumentsiz urinamiz
        return ServiceCls()


# ---------- DB aliaslar (DependencyMiddleware uchun) ----------
container.register(AsyncPGPool, factory=lambda: cast(AsyncPGPool, _pool_or_none()))
container.register(
    async_sessionmaker, factory=lambda: cast(async_sessionmaker, _pool_or_none())
)

# ---------- Repository factory'lari (punq) ----------
container.register(
    UserRepository, factory=as_singleton(lambda: _make_repo(UserRepository))
)
container.register(
    PlanRepository, factory=as_singleton(lambda: _make_repo(PlanRepository))
)
container.register(
    ChannelRepository, factory=as_singleton(lambda: _make_repo(ChannelRepository))
)
container.register(
    SchedulerRepository, factory=as_singleton(lambda: _make_repo(SchedulerRepository))
)
container.register(
    AnalyticsRepository, factory=as_singleton(lambda: _make_repo(AnalyticsRepository))
)

# ---------- Service factory'lari (punq) ----------
try:
    from bot.services.guard_service import GuardService
    from bot.services.subscription_service import SubscriptionService
    from bot.services.scheduler_service import SchedulerService
    from bot.services.analytics_service import AnalyticsService

    container.register(
        GuardService, factory=as_singleton(lambda: _make_service(GuardService))
    )
    container.register(
        SubscriptionService,
        factory=as_singleton(lambda: _make_service(SubscriptionService)),
    )
    container.register(
        SchedulerService, factory=as_singleton(lambda: _make_service(SchedulerService))
    )
    container.register(
        AnalyticsService, factory=as_singleton(lambda: _make_service(AnalyticsService))
    )
except Exception:
    # optional import failures allowed
    pass


# -------- Typed helper (Pylance uchun) --------
_T = TypeVar("_T")


def _resolve(key: Type[_T]) -> _T:
    return cast(_T, container.resolve(key))
