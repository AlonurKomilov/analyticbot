name: 🚀 Release Automation

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
        type: string
      release_type:
        description: 'Type of release'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
        default: patch
      skip_tests:
        description: 'Skip test suite (emergency release only)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Validate release prerequisites
  validate-release:
    name: 🔍 Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          if [[ "${VERSION}" =~ -alpha|-beta|-rc ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate version format
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ ! "${VERSION}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "❌ Invalid version format: ${VERSION}"
            echo "Expected format: v1.2.3 or v1.2.3-alpha.1"
            exit 1
          fi

      - name: Check for existing release
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if gh release view "${VERSION}" > /dev/null 2>&1; then
            echo "❌ Release ${VERSION} already exists"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate changelog entry
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if ! grep -q "${VERSION}" CHANGELOG.md; then
            echo "❌ No changelog entry found for version ${VERSION}"
            echo "Please update CHANGELOG.md before creating a release"
            exit 1
          fi

  # Run comprehensive tests unless skipped
  run-tests:
    name: 🧪 Run Release Tests
    runs-on: ubuntu-latest
    needs: validate-release
    if: github.event.inputs.skip_tests != 'true'
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    strategy:
      matrix:
        python-version: ["3.11", "3.12"]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio

      - name: Run database migrations
        run: |
          export DATABASE_URL="postgresql://testuser:testpass@localhost:5432/testdb"
          alembic upgrade head
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb

      - name: Run comprehensive test suite
        run: |
          export DATABASE_URL="postgresql://testuser:testpass@localhost:5432/testdb"
          export REDIS_URL="redis://localhost:6379"
          pytest -v --cov=bot --cov-report=xml --cov-report=term-missing
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: release-tests

  # Build and test Docker images
  build-images:
    name: 🐳 Build Release Images
    runs-on: ubuntu-latest
    needs: [validate-release, run-tests]
    if: always() && needs.validate-release.result == 'success' && (needs.run-tests.result == 'success' || needs.run-tests.result == 'skipped')
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Test Docker image
        run: |
          # Pull the built image and test basic functionality
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}

          # Run basic smoke test
          docker run --rm -e BOT_TOKEN=dummy_token ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }} python -c "import bot; print('✅ Import successful')"

  # Create GitHub release
  create-release:
    name: 📦 Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-release, run-tests, build-images]
    if: always() && needs.validate-release.result == 'success' && (needs.run-tests.result == 'success' || needs.run-tests.result == 'skipped') && needs.build-images.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: release-notes
        run: |
          VERSION="${{ needs.validate-release.outputs.version }}"

          # Extract changelog for this version
          if [ -f CHANGELOG.md ]; then
            # Get content between current version and previous version
            awk "/^## \[?${VERSION#v}\]?/ {flag=1; next} /^## \[?[0-9]/ {flag=0} flag" CHANGELOG.md > release_notes.md
          else
            echo "Release ${VERSION}" > release_notes.md
          fi

          # Add Docker image information
          echo "" >> release_notes.md
          echo "## 🐳 Docker Images" >> release_notes.md
          echo "" >> release_notes.md
          echo "```bash" >> release_notes.md
          echo "# Pull the latest release" >> release_notes.md
          echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}" >> release_notes.md
          echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> release_notes.md
          echo "```" >> release_notes.md
          echo "" >> release_notes.md
          echo "**Image Digest:** \`${{ needs.build-images.outputs.image-digest }}\`" >> release_notes.md

          # Add deployment information
          echo "" >> release_notes.md
          echo "## 🚀 Deployment" >> release_notes.md
          echo "" >> release_notes.md
          echo "### Docker Compose" >> release_notes.md
          echo "```bash" >> release_notes.md
          echo "# Update docker-compose.yml to use ${VERSION}" >> release_notes.md
          echo "docker-compose pull" >> release_notes.md
          echo "docker-compose up -d" >> release_notes.md
          echo "```" >> release_notes.md

          if [[ "${{ needs.validate-release.outputs.is_prerelease }}" == "true" ]]; then
            echo "" >> release_notes.md
            echo "⚠️ **This is a pre-release version** - use with caution in production environments." >> release_notes.md
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.validate-release.outputs.version }}
          name: Release ${{ needs.validate-release.outputs.version }}
          body_path: release_notes.md
          prerelease: ${{ needs.validate-release.outputs.is_prerelease }}
          draft: false
          generate_release_notes: true
          make_latest: ${{ needs.validate-release.outputs.is_prerelease == 'false' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Security scan of release artifacts
  security-scan:
    name: 🔒 Security Scan Release
    runs-on: ubuntu-latest
    needs: [validate-release, build-images]
    if: needs.build-images.result == 'success'
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Notify stakeholders
  notify:
    name: 📢 Notify Stakeholders
    runs-on: ubuntu-latest
    needs: [validate-release, create-release]
    if: needs.create-release.result == 'success'
    steps:
      - name: Notify Slack
        if: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          VERSION="${{ needs.validate-release.outputs.version }}"
          PRERELEASE="${{ needs.validate-release.outputs.is_prerelease }}"

          if [[ "${PRERELEASE}" == "true" ]]; then
            EMOJI="🧪"
            RELEASE_TYPE="Pre-release"
          else
            EMOJI="🚀"
            RELEASE_TYPE="Release"
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"${EMOJI} ${RELEASE_TYPE} ${VERSION} is now available!\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*${EMOJI} AnalyticBot ${RELEASE_TYPE} ${VERSION}*\n\nA new release is now available on GitHub.\n\n<https://github.com/${{ github.repository }}/releases/tag/${VERSION}|View Release Notes>\"
                  }
                }
              ]
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create deployment issue
        if: needs.validate-release.outputs.is_prerelease == 'false'
        run: |
          VERSION="${{ needs.validate-release.outputs.version }}"
          gh issue create \
            --title "🚀 Deploy ${VERSION} to Production" \
            --body "## Deployment Checklist for ${VERSION}

          - [ ] Verify all tests pass
          - [ ] Review security scan results
          - [ ] Backup production database
          - [ ] Deploy to staging environment
          - [ ] Run staging smoke tests
          - [ ] Deploy to production
          - [ ] Monitor deployment metrics
          - [ ] Verify functionality post-deployment

          **Release Notes:** https://github.com/${{ github.repository }}/releases/tag/${VERSION}
          **Docker Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}\`
          " \
            --label "deployment" \
            --label "high-priority" \
            --assignee "${{ github.actor }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Cleanup on failure
  cleanup-on-failure:
    name: 🧹 Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [validate-release, run-tests, build-images, create-release]
    if: failure()
    steps:
      - name: Delete failed release
        if: needs.create-release.result == 'failure'
        run: |
          VERSION="${{ needs.validate-release.outputs.version }}"
          if gh release view "${VERSION}" > /dev/null 2>&1; then
            echo "Deleting failed release ${VERSION}"
            gh release delete "${VERSION}" --yes
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify failure
        if: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          VERSION="${{ needs.validate-release.outputs.version }}"
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"❌ Release ${VERSION} failed!\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*❌ Release Failure*\n\nRelease ${VERSION} failed during the automated release process.\n\n<https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow Run>\"
                  }
                }
              ]
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }}
